{"name":"(lutronqs_daemon)","type":"virtual_device","properties":{"deviceIcon":0,"currentIcon":"0","log":"nil","logTemp":"TxtGreen","mainLoop":"","ui.err.value":"","ui.lastcmd.value":"","ui.status.value":"listening","ui.stopflag.value":"0","visible":"true","rows":[{"type":"label","elements":[{"id":1,"lua":false,"waitForResponse":false,"caption":"Status","name":"status","favourite":false,"main":true}]},{"type":"button","elements":[{"id":2,"lua":true,"waitForResponse":false,"caption":"(Start)","name":"button_1_1","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\nG_VAR_NAME_WD_STOP = 'gLu_WD_Stop'     -- Watch Dog Stop Flag \n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _INFO\n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron daemon enter', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\nTrace('check daemon state ' .. fibaro:getGlobal(G_VAR_NAME_STATE))\nif (fibaro:getGlobal(G_VAR_NAME_STATE) == 'BUSY') then\n    fibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , 'State Busy' )\n    Trace('lutron daemon exit')\n    return\nend\n\nfibaro:setGlobal(G_VAR_NAME_STOP, '')\nTrace('reset daemon stop flag ' .. fibaro:getGlobal(G_VAR_NAME_STOP))\nfibaro:call( selfID , \"setProperty\" , \"ui.stopflag.value\" , false )\n\nfibaro:setGlobal(G_VAR_NAME_CMD, '')\nTrace('reset daemon cmd queue ' .. fibaro:getGlobal(G_VAR_NAME_STOP))\nfibaro:call( selfID , \"setProperty\" , \"ui.lastcmd.value\" , '' )\n\nfibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , '' )\n\n--fibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , '' )\n--fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'Starting' )\n--fibaro:call( selfID , \"setProperty\" , \"ui.lastcmd.value\" , '' )\n\nfunction lutron_data_handler(_data)\n    Trace('_data: ' .. _data)\n    if _data ~= 'QNET> ' then\n        fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'receiving data' )\n    end\n    local last_data\n    local meta = fibaro:getGlobal(G_VAR_NAME_META)\n    Trace('meta: ' .. tostring(meta) .. ',type: ' .. type(meta))\n    if meta == nil or meta == '' then\n        -- first initial\n    \tTrace('meta initial')\n        meta = {}\n    else\n    \tmeta = json.decode(meta)\n    end\n    local devDataFlag = false\n    for entry in string.gmatch(_data .. '\\r\\n','~(.-)%\\r%\\n') do\n        Trace('match cmd: ' .. entry)\n        local devType = string.match(entry,'(.-),')\n        local devID, pre_state, logType = _DEBUG\n        Trace('devType ' .. devType)\n        if devType == 'DEVICE' or devType == 'OUTPUT' then\n            devID = string.match(entry,',(%d+,%d+),')\n            pre_state = meta[devID]\n            meta[devID] = entry\n            if pre_state ~= entry then\n                logType = _INFO\n            end\n            Trace('devID ' .. tostring(devID) .. ', pre_state ' .. tostring(pre_state) .. ', new_state ' .. tostring(entry), logType)\n        else\n            Trace('unknow devType ' .. devType, _WARNING)\n        end\n        last_data = entry\n        devDataFlag = true\n    end\n    if devDataFlag then\n        fibaro:setGlobal(G_VAR_NAME_META,json.encode(meta))\n        meta = fibaro:getGlobal(G_VAR_NAME_META)\n        Trace('updated meta: ' .. meta, _INFO)\n    end\n    fibaro:log(tostring(last_data))\n    \nend\n\nfunction service_run()\n\n    fibaro:setGlobal(G_VAR_NAME_STATE, 'BUSY')\n    fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'Starting' )\n    Trace('daemon start', _INFO)\n\n    local socket\n    local status , err = pcall(\n        function() \n            socket = Net.FTcpSocket( ipAddress , tcpPort )\n            socket:setReadTimeout( 3000 )\n        end )  \n    if status ~= nil and status ~= true then\n        Trace( \"socket status: \" .. tostring( status or \"\" ) )\n    end  \n    if err ~= nil then\n        Trace( \"socket err: \" .. tostring( err or \"\" ), _ERROR )\n        fibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , 'SCK ERROR' )\n    else\n        local bytes, errCode, rdata\n        rdata, errCode = socket:read()\n        Trace( 'socket read result code ' .. tostring(errCode) .. ' data: ' .. tostring(rdata) )\n        -- login process start\n        if string.find(rdata,'login') == 1 then\n            Trace('enter account ...')\n            bytes, errCode = socket:write(ACCOUNT .. '\\r\\n')\n            Trace( 'socket write result code ' .. tostring(errCode) .. ' bytes: ' .. tostring(bytes) )\n            rdata, errCode = socket:read()\n            Trace( 'socket read result code ' .. tostring(errCode) .. ' data: ' .. tostring(rdata) )\n            if string.find(rdata,'password') == 1 then\n                Trace('enter password ...')\n                bytes, errCode = socket:write(PASSWORD .. '\\r\\n')\n                Trace( 'socket write result code ' .. tostring(errCode) .. ' bytes: ' .. tostring(bytes) )\n                rdata, errCode = socket:read()\n                Trace( 'socket read result code ' .. tostring(errCode) .. ' data: ' .. tostring(rdata) )\n                if string.find(rdata,'>') > 1 then\n                    -- login process finish\n                    fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'logon', _INFO )\n                    Trace('login success', _INFO)\n                    local count = 0\n                    local MAX_COUNT = 4\n                    local stopflag = fibaro:getGlobal(G_VAR_NAME_STOP)\n                    while ( tostring(stopflag) ~= 'true' ) do\n                        \n                        -- sck conn check process: make lutron must response data\n                        bytes, errCode = socket:write('\\r\\n')\n                        Trace( 'socket write result code ' .. tostring(errCode) .. ' bytes: ' .. tostring(bytes) )\n                        \n                        -- listening process\n                        fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'listening' )\n                        rdata, errCode = socket:read()\n                        Trace( 'socket read result code ' .. tostring(errCode) .. ' data: ' .. tostring(rdata) )\n                        if rdata ~= '' then\n                            if rdata ~= 'QNET> ' then\n                                Trace('receive data: ' .. rdata, _INFO)\n                            end\n                        end\n                        \n                        if errCode ~= 0 then\n                            -- socket connection broken event, break loop; let watchdog restart daemon\n                            Trace('connection broken', _WARNING)\n                            break\n                        end\n                        \n                        -- read data processing\n                        if rdata ~= '' then\n                            lutron_data_handler(rdata)\n                        end\n                        \n                        -- cmd handling\n                        cmd = fibaro:getGlobal(G_VAR_NAME_CMD)\n                        Trace('check cmd queue: ' .. tostring(cmd))\n                        if cmd ~= '' and cmd ~= nil then\n                            fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'execute cmd' )\n                            fibaro:setGlobal(G_VAR_NAME_CMD, '')\n                            Trace('clear cmd queue and handle cmd')\n                            Trace('process cmd: ' .. cmd, _INFO)\n                            bytes, errCode = socket:write(cmd .. '\\r\\n')\n                            Trace( 'socket write result code ' .. tostring(errCode) .. ' bytes: ' .. tostring(bytes) )\n                            fibaro:call( selfID , \"setProperty\" , \"ui.lastcmd.value\" , cmd )\n                        else\n                            fibaro:sleep(500)\n                        end\n                        \n                        -- check daemon stop flag\n                        stopflag = fibaro:getGlobal(G_VAR_NAME_STOP)\n                        Trace('check stop flag ' .. tostring(stopflag))\n                    end\n                end\n            end\n        end\n        if errCode ~= 0 and errCode ~= SCK_READ_TIMEOUT_ERR_CODE then\n            fibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , 'sck err code ' .. tostring(errCode) )\n\n        end\n    end\n    -- socket disconnect\n    socket:disconnect()\n    socket = nil\n    \n    \n    fibaro:setGlobal(G_VAR_NAME_STATE,'')\n    fibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , 'STOP' )\n    Trace('daemon exit', _INFO)\nend\n\nservice_run()\n\n\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"button","elements":[{"id":3,"lua":true,"waitForResponse":false,"caption":"(Stop)","name":"Button21","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _DEBUG \n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron daemon exit', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\nTrace('current state:' .. fibaro:getGlobal(G_VAR_NAME_STATE) .. ' stop flag: ' .. fibaro:getGlobal(G_VAR_NAME_STOP))\nfibaro:setGlobal(G_VAR_NAME_STOP, 'true')\nlocal stopflag = fibaro:getGlobal(G_VAR_NAME_STOP)\nfibaro:call( selfID , \"setProperty\" , \"ui.stopflag.value\" , stopflag )\n\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"label","elements":[{"id":4,"lua":false,"waitForResponse":false,"caption":"LastCmd","name":"lastcmd","favourite":false,"main":false}]},{"type":"label","elements":[{"id":5,"lua":false,"waitForResponse":false,"caption":"StopFlag","name":"stopflag","favourite":false,"main":false}]},{"type":"label","elements":[{"id":6,"lua":false,"waitForResponse":false,"caption":"ERR","name":"err","favourite":false,"main":false}]},{"type":"button","elements":[{"id":7,"lua":true,"waitForResponse":false,"caption":"ON/OFF","name":"Button51","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\nBTN_START_ID = 2\nBTN_STOP_ID = 3\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _DEBUG\n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron daemon switch', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\nlocal vdev_state = fibaro:getGlobal(G_VAR_NAME_STATE)\nTrace('current state is ' .. vdev_state)\nif vdev_state == 'BUSY' then\n    fibaro:log('Stoping Daemon')\n    Trace('active daemon stop')\n    fibaro:call( selfID , \"pressButton\" , BTN_STOP_ID )\n    \nelse\n    fibaro:log('Starting Deamon')\n    Trace('activate datemon start')\n    fibaro:call( selfID , \"pressButton\" , BTN_START_ID )\nend\n","buttonIcon":0,"favourite":false,"main":true}]},{"type":"button","elements":[{"id":8,"lua":true,"waitForResponse":false,"caption":"(Reset)","name":"Button31","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _DEBUG \n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron daemon exit', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\n--fibaro:setGlobal(G_VAR_NAME_META, '')\nfibaro:setGlobal(G_VAR_NAME_STATE, '')\nfibaro:setGlobal(G_VAR_NAME_CMD, '')\nfibaro:setGlobal(G_VAR_NAME_STOP, 'true')\n\nfibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.lastcmd.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.stopflag.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , '' )\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"button","elements":[{"id":9,"lua":true,"waitForResponse":false,"caption":"(Reset + Meta)","name":"Button41","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _DEBUG \n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron daemon exit', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\nfibaro:setGlobal(G_VAR_NAME_META, '')\nfibaro:setGlobal(G_VAR_NAME_STATE, '')\nfibaro:setGlobal(G_VAR_NAME_CMD, '')\nfibaro:setGlobal(G_VAR_NAME_STOP, 'true')\n\nfibaro:call( selfID , \"setProperty\" , \"ui.status.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.lastcmd.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.stopflag.value\" , '' )\nfibaro:call( selfID , \"setProperty\" , \"ui.err.value\" , '' )\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"button","elements":[{"id":10,"lua":true,"waitForResponse":false,"caption":"Stop WatchDog","name":"Button61","empty":false,"msg":"--[[\n    @Global Variable: \n        gLu_D_Cmd: command to be sent for Lutron QS\n        gLu_D_State: true (activate) or false (deactivate)\n        gLu_D_Meta: json data storage for Lutron devices status\n        gLu_D_Stop: true (stop daemon) or false (start daemon)\n--]]\n\n-- device constant\nACCOUNT = 'fibaro'\nPASSWORD = 'fibaro'\n\n-- global variable in used\nG_VAR_NAME_META = 'gLu_D_Meta'\nG_VAR_NAME_STATE = 'gLu_D_State'\nG_VAR_NAME_CMD = 'gLu_D_Cmd'\nG_VAR_NAME_STOP = 'gLu_D_Stop'\nG_VAR_NAME_WD_STOP = 'gLu_WD_Stop'     -- Watch Dog Stop Flag \n\n-- debug function declare\n_DEBUG = 10\n_INFO = 20\n_WARNING = 30\n_ERROR = 40\nlogLevel = _INFO\n\nfunction Trace( _text , _weight )\n    _weight = _weight or _DEBUG\n  \tif _weight == _INFO then\n    \t_color = 'white'\n    elseif _weight >= _WARNING then\n    \t_color = 'red'\n    else\n    \t_color = \"gray\"\n    end\n    if _weight >= logLevel then\n        fibaro:debug( '<span style=\"color:' .. _color .. '\">' .. tostring( _text ) .. '</span><p>' )\n    end\nend\n\nTrace('lutron watch dog stop', _DEBUG)\n\n-- variable initial\nlocal selfID = fibaro:getSelfId()\nlocal ipAddress = fibaro:getValue( selfID , \"IPAddress\" )\nlocal tcpPort = fibaro:getValue( selfID , \"TCPPort\" )\nTrace('Socket Server IP: ' .. ipAddress .. ' listen port: ' .. tcpPort)\n\nTrace('current watchdog stop flag:' .. tostring(fibaro:getGlobal(G_VAR_NAME_WD_STOP)))\nfibaro:setGlobal(G_VAR_NAME_WD_STOP, 'true')\nfibaro:log('stop watch dog')\n","buttonIcon":0,"favourite":false,"main":false}]}]},"actions":{"pressButton":1,"setSlider":2,"setProperty":2}}